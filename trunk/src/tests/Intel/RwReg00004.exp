// fn10000000
// Mem0:Global memory
// fp:Temporary
// dwArg04:Stack +0004
// eax:Register
// ebx:Register
// dwLoc04:Local -0004
// dwArg06:Stack +0006
// ebp:Register
// dwLoc08:Local -0008
// ecx:Register
// edx:Register
// dwArg08:Stack +0008
// dwArg10:Stack +0010
// SCZO:Flags
// C:Flags
// dwArg0C:Stack +000C
// Z:Flags
// rLoc1:FPU stack
// esi:Register
// dwLoc0C:Local -000C
// edi:Register
// dwLoc10:Local -0010
// rArg0C:Stack +000C
// rLoc2:FPU stack
// SZO:Flags
// ax:Register
// ah:Register
// rArg04:Stack +0004
// rLoc3:FPU stack
// rLoc4:FPU stack
// SO:Flags
// return address size: 4
void fn10000000()
fn10000000_entry:		// block 0, pred:
	// succ:  1
l10000000:		// block 1, pred: 0
	eax = dwArg04
	dwLoc04 = ebx
	ebx = dwArg06
	dwLoc08 = ebp
	ecx = (int32) Mem0[eax + 0x00000006:word16]
	edx = (int32) Mem0[eax + 0x00000002:word16]
	ebp = dwArg08
	ecx = ecx - edx
	edx = dwArg10
	store(Mem0[ebx:word32]) = ecx
	ecx = (int32) Mem0[eax + 0x00000004:word16]
	eax = (int32) Mem0[eax:word16]
	ecx = ecx - eax
	SCZO = cond(ebp - 0x00000000)
	C = false
	dwArg0C = ecx
	store(Mem0[edx:word32]) = ecx
	branch Test(EQ,Z)
	// succ:  2 14
l10000035:		// block 2, pred: 1
	rLoc1 = Mem0[ebx:real64]
	dwLoc0C = esi
	dwLoc10 = edi
	esi = 0x00000000
	SCZO = cond(esi)
	edi = 0x000186A0
	dwArg04 = rLoc1
	rLoc1 = rArg0C
	// succ:  3
l10000048:		// block 3, pred: 2 11
	rLoc2 = dwArg04
	rLoc2 = rLoc2 * Mem0[0x0099188A:real64]
	esi = esi + 0x00000001
	SZO = cond(esi)
	dwArg04 = rLoc2
	call fn10000108 (depth: 16; FPU: 2;)
	ecx = eax
	dwArg0C = ecx
	rLoc2 = rArg0C
	C = rLoc2 - dwArg04
	ax = C
	SCZO = cond(ah & 0x40)
	C = false
	branch Test(NE,Z)
	// succ:  4 5
l10000072:		// block 4, pred: 3
	ecx = ecx + 0x00000001
	SZO = cond(ecx)
	dwArg04 = ecx
	rLoc2 = rArg04
	dwArg04 = rLoc2
	// succ:  5
l1000007F:		// block 5, pred: 4 3
	rLoc1 = rLoc1 * Mem0[0x10033290:real64]
	rLoc2 = rLoc2
	call fn10000108 (depth: 16; FPU: 2;)
	ecx = eax
	dwArg0C = ecx
	rLoc2 = rArg0C
	rLoc3 = rLoc2
	ax = C
	SCZO = cond(ah & 0x40)
	C = false
	branch Test(NE,Z)
	// succ:  6 7
l100000A0:		// block 6, pred: 5
	ecx = ecx + 0x00000001
	SZO = cond(ecx)
	rLoc3 = rLoc3
	dwArg0C = ecx
	rLoc3 = rArg0C
	// succ:  7
l100000AB:		// block 7, pred: 6 5
	rLoc4 = dwArg04
	C = rLoc4 - Mem0[0x10033298:real64]
	ax = C
	SCZO = cond(ah & 0x40)
	C = false
	branch Test(EQ,Z)
	// succ:  8 11
l100000BD:		// block 8, pred: 7
	C = rLoc3 - Mem0[0x10033298:real64]
	ax = C
	SCZO = cond(ah & 0x40)
	C = false
	branch Test(EQ,Z)
	// succ:  9 11
l100000CB:		// block 9, pred: 8
	SCZO = cond(edi - 0x000186A0)
	branch Test(NE,Z)
	// succ:  10 11
l100000D3:		// block 10, pred: 9
	edi = esi
	// succ:  11
l100000D5:		// block 11, pred: 10 9 8 7
	SCZO = cond(esi - ebp)
	branch Test(LT,SO)
	// succ:  12 3
l100000DD:		// block 12, pred: 11
	rLoc4 = dwArg04
	call fn10000108 (depth: 16; FPU: 4;)
	store(Mem0[ebx:word32]) = eax
	call fn10000108 (depth: 16; FPU: 3;)
	ecx = dwArg10
	SCZO = cond(ebp - edi)
	edi = dwLoc10
	esi = dwLoc0C
	store(Mem0[ecx:word32]) = eax
	branch Test(LE,SZO)
	// succ:  13 14
l100000F9:		// block 13, pred: 12
	store(Mem0[ebx:word32]) = 0x00000000
	store(Mem0[ecx:word32]) = 0x00000000
	// succ:  14
l10000105:		// block 14, pred: 13 12 1
	ebp = dwLoc08
	ebx = dwLoc04
	return
	// succ:  15
fn10000000_exit:		// block 15, pred: 14
	// succ: 

// fn10000108
// Mem0:Global memory
// fp:Temporary
// rArg0:FPU stack
// rLoc04:Local -0004
// eax:Register
// return address size: 4
void fn10000108()
fn10000108_entry:		// block 0, pred:
	// succ:  1
l10000108:		// block 1, pred: 0
	rLoc04 = rArg0
	eax = rLoc04
	return
	// succ:  2
fn10000108_exit:		// block 2, pred: 1
	// succ: 

