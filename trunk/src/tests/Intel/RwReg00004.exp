// fn10000000
// Mem0:Global memory
// fp:Temporary
// esp:Register esp
// eax:Register eax
// ebx:Register ebx
// ebp:Register ebp
// ecx:Register ecx
// edx:Register edx
// SCZO:Flags
// SZO:Flags
// C:Flags
// Z:Flags
// rLoc1:FPU stack
// esi:Register esi
// edi:Register edi
// rLoc2:FPU stack
// rLoc3:FPU stack
// FPUF:Flags
// ax:Register ax
// ah:Register ah
// rLoc3:FPU stack
// SO:Flags
// return address size: 4
void fn10000000()
fn10000000_entry:
l10000000:
	eax = Mem0[esp + 0x00000004:word32]
	esp = esp - 0x00000004
	store(Mem0[esp:word32]) = ebx
	ebx = Mem0[esp + 0x00000010:word32]
	esp = esp - 0x00000004
	store(Mem0[esp:word32]) = ebp
	ecx = (int32) Mem0[eax + 0x00000006:word16]
	edx = (int32) Mem0[eax + 0x00000002:word16]
	ebp = Mem0[esp + 0x00000010:word32]
	ecx = ecx - edx
	SCZO = cond(ecx)
	edx = Mem0[esp + 0x00000018:word32]
	store(Mem0[ebx:word32]) = ecx
	ecx = (int32) Mem0[eax + 0x00000004:word16]
	eax = (int32) Mem0[eax:word16]
	ecx = ecx - eax
	SCZO = cond(ecx)
	SZO = cond(ebp & ebp)
	C = false
	store(Mem0[esp + 0x00000014:word32]) = ecx
	store(Mem0[edx:word32]) = ecx
	branch Test(EQ,Z) l10000107
l10000035:
	rLoc1 = (real64)Mem0[ebx:int32]
	esp = esp - 0x00000004
	store(Mem0[esp:word32]) = esi
	esp = esp - 0x00000004
	store(Mem0[esp:word32]) = edi
	esi = esi ^ esi
	SZO = cond(esi)
	C = false
	edi = 0x000186A0
	store(Mem0[esp + 0x00000014:real32]) = rLoc1
	rLoc1 = (real64) Mem0[esp + 0x0000001C:int32]
l10000048:
	rLoc2 = Mem0[esp + 0x00000014:real32]
	rLoc2 = rLoc2 *s Mem0[0x0099188A:real64]
	esi = esi + 0x00000001
	SZO = cond(esi)
	store(Mem0[esp + 0x00000014:real32]) = rLoc2
	call fn1000010A (depth: 0;)
	ecx = eax
	store(Mem0[esp + 0x0000001C:word32]) = ecx
	rLoc2 = (real64) Mem0[esp + 0x0000001C:int32]
	FPUF = cond(rLoc2 - Mem0[esp + 0x0000001C:real32])
	ax = (word16) FPUF << 8
	SZO = cond(ah & 0x40)
	C = false
	branch Test(NE,Z) l1000007F
l10000072:
	ecx = ecx + 0x00000001
	SZO = cond(ecx)
	store(Mem0[esp + 0x00000014:word32]) = ecx
	rLoc2 = (real64) Mem0[esp + 0x00000014:int32]
	store(Mem0[esp + 0x00000014:real32]) = (word32) rLoc2
l1000007F:
	rLoc1 = rLoc1 *s Mem0[0x10033290:real64]
	rLoc2 = rLoc2
	call fn1000010A (depth: 0;)
	ecx = eax
	store(Mem0[esp + 0x0000001C:word32]) = ecx
	rLoc2 = (real64) Mem0[esp + 0x0000001C:word32]
	rLoc3 = rLoc1
	FPUF = cond(rLoc3 - rLoc2)
	ax = (word16) FPUF << 8
	SZO = cond(ah & 0x40)
	C = false
	branch Test(NE,Z) l100000AD
l100000A2:
	ecx = ecx + 0x00000001
	SZO = cond(ecx)
	rLoc1 = rLoc1
	store(Mem0[esp + 0x0000001C:word32]) = ecx
	rLoc1 = (real64) Mem0[esp + 0x0000001C:int32]
l100000AD:
	rLoc2 = Mem0[esp + 0x00000014:real32]
	FPUF = cond(rLoc2 - Mem0[0x10033298:real64])
	ax = (word16) FPUF << 8
	SZO = cond(ah & 0x40)
	C = false
	branch Test(EQ,Z) l100000D7
l100000BF:
	FPUF = cond(rLoc1 - Mem0[0x10033298:real64])
	ax = (word16) FPUF << 8
	SZO = cond(ah & 0x40)
	C = false
	branch Test(EQ,Z) l100000D7
l100000CD:
	SCZO = cond(edi - 0x000186A0)
	branch Test(NE,Z) l100000D7
l100000D5:
	edi = esi
l100000D7:
	SCZO = cond(esi - ebp)
	branch Test(LT,SO) l10000048
l100000DF:
	rLoc2 = Mem0[esp + 0x0000014:real32]
	call fn1000010A (depth: 0;)
	store(Mem0[ebx:word32]) = eax
	call fn1000010A (depth: 0;)
	ecx = Mem0[esp + 0x00000020:word32]
	SCZO = cond(ebp - edi)
	edi = Mem0[esp:word32]
	esp = esp + 0x00000004
	esi = Mem0[esp:word32]
	esp = esp + 0x00000004
	store(Mem0[ecx:word32]) = eax
	branch Test(LE,SZO) l10000107
l100000FB:
	store(Mem0[ebx:word32]) = 0x00000000
	store(Mem0[ecx:word32]) = 0x00000000
l10000107:
	ebp = Mem0[esp:word32]
	esp = esp + 0x00000004
	ebx = Mem0[esp:word32]
	esp = esp + 0x00000004
	return
fn10000000_exit:

// fn1000010A
// Mem0:Global memory
// fp:Temporary
// rArg0:FPU stack
// esp:Register esp
// eax:Register eax
// return address size: 4
void fn1000010A()
fn1000010A_entry:
l1000010A:	
	store(Mem0[esp - 0x00000004:int32]) = (int32) rArg0
	eax = Mem0[esp - 0x00000004:word32]
	return
fn1000010A_exit:

