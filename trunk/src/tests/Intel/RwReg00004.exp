// fn10000000
// Mem0:Global memory
// fp:Temporary
// dwArg00:Stack +0000
// eax:Register eax
// ebx:Register ebx
// dwLoc08:Local -0008
// dwArg02:Stack +0002
// ebp:Register ebp
// dwLoc0C:Local -000C
// ecx:Register ecx
// edx:Register edx
// dwArg04:Stack +0004
// dwArg0C:Stack +000C
// SCZO:Flags
// C:Flags
// dwArg08:Stack +0008
// Z:Flags
// rLoc1:FPU stack
// esi:Register esi
// dwLoc10:Local -0010
// edi:Register edi
// dwLoc14:Local -0014
// rArg08:Stack +0008
// rLoc2:FPU stack
// FPUF:Flags
// ax:Register ax
// ah:Register ah
// rLoc3:FPU stack
// SO:Flags
// SZO:Flags
// rArg00:Stack +0000
// return address size: 4
void fn10000000()
fn10000000_entry:		// pred:
	// succ:  l10000000
l10000000:		// pred: fn10000000_entry
	eax = dwArg00
	dwLoc08 = ebx
	ebx = dwArg02
	dwLoc0C = ebp
	ecx = (int32) Mem0[eax + 0x00000006:word16]
	edx = (int32) Mem0[eax + 0x00000002:word16]
	ebp = dwArg04
	ecx = ecx - edx
	edx = dwArg0C
	store(Mem0[ebx:word32]) = ecx
	ecx = (int32) Mem0[eax + 0x00000004:word16]
	eax = (int32) Mem0[eax:word16]
	ecx = ecx - eax
	SCZO = cond(ebp - 0x00000000)
	C = false
	dwArg08 = ecx
	store(Mem0[edx:word32]) = ecx
	branch Test(EQ,Z) l10000107
	// succ:  l10000035 l10000107
l10000035:		// pred: l10000000
	rLoc1 = Mem0[ebx:real64]
	dwLoc10 = esi
	dwLoc14 = edi
	esi = 0x00000000
	SCZO = cond(esi)
	edi = 0x000186A0
	dwArg00 = rLoc1
	rLoc1 = rArg08
	// succ:  l10000048
l10000048:		// pred: l10000035 l100000D7
	rLoc2 = dwArg00
	rLoc2 = rLoc2 *s Mem0[0x0099188A:real64]
	esi = esi + 0x00000001
	dwArg00 = rLoc2
	call fn1000010A (depth: 20; FPU: 2;)
	ecx = eax
	dwArg08 = ecx
	rLoc2 = rArg08
	FPUF = cond(rLoc2 - dwArg00)
	ax = (word16) FPUF << 8
	SCZO = cond(ah & 0x40)
	C = false
	branch Test(EQ,FPUF) l1000007F
	// succ:  l10000072 l1000007F
l10000072:		// pred: l10000048
	ecx = ecx + 0x00000001
	SZO = cond(ecx)
	dwArg00 = ecx
	rLoc2 = rArg00
	dwArg00 = rLoc2
	// succ:  l1000007F
l1000007F:		// pred: l10000048 l10000072
	rLoc1 = rLoc1 *s Mem0[0x10033290:real64]
	rLoc2 = rLoc2
	call fn1000010A (depth: 20; FPU: 2;)
	ecx = eax
	dwArg08 = ecx
	rLoc2 = rArg08
	rLoc3 = rLoc2
	FPUF = cond(rLoc3 - rLoc2)
	ax = (word16) FPUF << 8
	SCZO = cond(ah & 0x40)
	C = false
	branch Test(EQ,FPUF) l100000AD
	// succ:  l100000A2 l100000AD
l100000A2:		// pred: l1000007F
	ecx = ecx + 0x00000001
	SZO = cond(ecx)
	rLoc1 = rLoc1
	dwArg08 = ecx
	rLoc1 = rArg08
	// succ:  l100000AD
l100000AD:		// pred: l1000007F l100000A2
	rLoc2 = dwArg00
	FPUF = cond(rLoc2 - Mem0[0x10033298:real64])
	ax = (word16) FPUF << 8
	SCZO = cond(ah & 0x40)
	C = false
	branch Test(NE,FPUF) l100000D7
	// succ:  l100000BF l100000D7
l100000BF:		// pred: l100000AD
	FPUF = cond(rLoc1 - Mem0[0x10033298:real64])
	ax = (word16) FPUF << 8
	SCZO = cond(ah & 0x40)
	C = false
	branch Test(NE,FPUF) l100000D7
	// succ:  l100000CD l100000D7
l100000CD:		// pred: l100000BF
	SCZO = cond(edi - 0x000186A0)
	branch Test(NE,Z) l100000D7
	// succ:  l100000D5 l100000D7
l100000D5:		// pred: l100000CD
	edi = esi
	// succ:  l100000D7
l100000D7:		// pred: l100000AD l100000BF l100000CD l100000D5
	SCZO = cond(esi - ebp)
	branch Test(LT,SO) l10000048
	// succ:  l100000DF l10000048
l100000DF:		// pred: l100000D7
	rLoc2 = dwArg00
	call fn1000010A (depth: 20; FPU: 2;)
	store(Mem0[ebx:word32]) = eax
	call fn1000010A (depth: 20; FPU: 1;)
	ecx = dwArg0C
	SCZO = cond(ebp - edi)
	edi = dwLoc14
	esi = dwLoc10
	store(Mem0[ecx:word32]) = eax
	branch Test(LE,SZO) l10000107
	// succ:  l100000FB l10000107
l100000FB:		// pred: l100000DF
	store(Mem0[ebx:word32]) = 0x00000000
	store(Mem0[ecx:word32]) = 0x00000000
	// succ:  l10000107
l10000107:		// pred: l10000000 l100000DF l100000FB
	ebp = dwLoc0C
	ebx = dwLoc08
	return
	// succ:  fn10000000_exit
fn10000000_exit:		// pred: l10000107
	// succ: 

// fn1000010A
// Mem0:Global memory
// fp:Temporary
// rArg0:FPU stack
// rLoc08:Local -0008
// eax:Register eax
// return address size: 4
void fn1000010A()
fn1000010A_entry:		// pred:
	// succ:  l1000010A
l1000010A:		// pred: fn1000010A_entry
	rLoc08 = rArg0
	eax = rLoc08
	return
	// succ:  fn1000010A_exit
fn1000010A_exit:		// pred: l1000010A
	// succ: 

